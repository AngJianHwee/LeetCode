# # from typing import List


# # class Solution:
# #     def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
# #         dic = {}
# #         for x, y in logs:
# #             try:
# #                 dic[x] = min(y, dic[x])
# #             except:
# #                 dic[x] = y

# #         arr = [0 for i in range(k)]
# #         for x,y in dic.items():
# #             arr[y-1] += 1
# #         return arr


# # s = Solution()
# # print(s.findingUsersActiveMinutes(logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5))
# # print(s.findingUsersActiveMinutes(logs = [[1,1],[2,2],[2,3]], k = 4))
# # # # Model Solution



# X = [-0.15, 8.6, 5.0, 3.71, 4.29, 7.74, 2.48, 3.25, -1.15, 8.38]
# Y = [2.55, 12.07, 0.46, 0.35, 2.69, -0.94, 1.73, 0.73, -0.35, -0.37]
# print(sorted(X))
# print(sorted(Y))
# print(sorted(X+Y))



# # Python program for KMP Algorithm
# def KMPSearch(pat, txt):
# 	M = len(pat)
# 	N = len(txt)

# 	# create lps[] that will hold the longest prefix suffix
# 	# values for pattern
# 	lps = [0]*M
# 	j = 0 # index for pat[]

# 	# Preprocess the pattern (calculate lps[] array)
# 	computeLPSArray(pat, M, lps)

# 	i = 0 # index for txt[]
# 	while i < N:
# 		if pat[j] == txt[i]:
# 			i += 1
# 			j += 1

# 		if j == M:
# 			print ("Found pattern at index", str(i-j))
# 			j = lps[j-1]

# 		# mismatch after j matches
# 		elif i < N and pat[j] != txt[i]:
# 			# Do not match lps[0..lps[j-1]] characters,
# 			# they will match anyway
# 			if j != 0:
# 				j = lps[j-1]
# 			else:
# 				i += 1

# def computeLPSArray(pat, M, lps):
# 	len = 0 # length of the previous longest prefix suffix

# 	lps[0] # lps[0] is always 0
# 	i = 1

# 	# the loop calculates lps[i] for i = 1 to M-1
# 	while i < M:
# 		if pat[i]== pat[len]:
# 			len += 1
# 			lps[i] = len
# 			i += 1
# 		else:
# 			# This is tricky. Consider the example.
# 			# AAACAAAA and i = 7. The idea is similar
# 			# to search step.
# 			if len != 0:
# 				len = lps[len-1]

# 				# Also, note that we do not increment i here
# 			else:
# 				lps[i] = 0
# 				i += 1

# txt = "ABABDABACDABABCABAB"
# pat = "ABABCABAB"
# KMPSearch(pat, txt)

# # This code is contributed by Bhavya Jain




def func(n):
	if n == 1:
		return {}
	dic = {}
	
	if n%2 == 0:
		dic[2] = 1
		n = int(n/2)		
		while n%2 == 0:
			dic[2] += 1
			n = int(n/2)

	i = 3
	while i <= n:
		print(i)
		if n == 1:
			break
		if n%i == 0:
			dic[i] = 1
			n = int(n/i)
			while n%i == 0:
				dic[i] += 1
				n = int(n/i)
		i += 2
	return dic


# print(func(50))
# print(func(500))
# print(func(832483274807))




(11.33%)	21021/185491
(16.16%)	14084/87152
(16.82%)	5912/35151
(17.52%)	9866/56313
(17.80%)	876/4921
(18.14%)	15281/84255
(18.38%)	937/5099
(19.14%)	23687/123742
(20.24%)	7778/38430
(20.63%)	853/4134
(20.94%)	10908/52101
(21.09%)	42631/202171
(21.16%)	12455/58862
(21.40%)	10115/47268
(21.51%)	1010/4695
(21.70%)	12094/55743
(21.75%)	15383/70717
(21.78%)	11845/54379
(22.14%)	11759/53117
(23.34%)	11264/48257
(23.34%)	13364/57263
(23.69%)	7350/31023
(23.86%)	11500/48204
(23.88%)	10748/45017
(24.26%)	11302/46589
(24.30%)	15079/62063
(24.49%)	6982/28514
(24.51%)	10188/41562
(24.92%)	15737/63139
(25.00%)	11349/45394
(25.12%)	9213/36678
(25.44%)	10974/43141
(25.61%)	9668/37750
(25.66%)	19669/76645
(26.04%)	53607/205842
(26.15%)	9998/38232
(26.21%)	9046/34508
(26.36%)	14329/54356
(26.38%)	22116/83836
(26.39%)	855/3240
(26.47%)	8749/33047
(26.60%)	8211/30874
(26.61%)	8878/33365
(26.74%)	7734/28921
(26.77%)	7470/27904
(26.78%)	8574/32014
(26.86%)	16584/61743
(27.02%)	11487/42514
(27.05%)	18929/69975
(27.10%)	8557/31578
(27.30%)	11463/41994
(27.33%)	17404/63681
(27.36%)	13577/49632
(27.99%)	23119/82610
(28.29%)	9936/35116
(28.35%)	7525/26539
(28.62%)	17232/60215
(29.07%)	10859/37349
(29.16%)	24867/85286
(29.51%)	38854/131673
(29.59%)	10938/36959
(29.60%)	13100/44257
(29.63%)	882/2977
(29.83%)	10893/36521
(29.97%)	11935/39821
(30.12%)	10246/34013
(30.12%)	16984/56379
(30.29%)	12645/41751
(30.77%)	18714/60814
(30.80%)	17098/55513
(31.08%)	8619/27734
(31.20%)	11420/36608
(31.27%)	12489/39943
(31.33%)	7681/24513
(31.37%)	15069/48030
(31.41%)	8127/25870
(31.74%)	10759/33899
(31.91%)	14593/45731
(32.05%)	11088/34600
(32.54%)	7414/22782
(32.63%)	9575/29345
(32.82%)	15666/47737
(33.01%)	11454/34701
(33.03%)	7603/23016
(33.33%)	10960/32885
(33.37%)	16715/50094
(33.41%)	14820/44359
(33.49%)	24296/72538
(34.24%)	7482/21851
(34.30%)	10183/29692
(34.45%)	9469/27486
(34.55%)	11753/34022
(34.63%)	7566/21845
(34.82%)	764/2194
(35.10%)	15160/43193
(35.15%)	7234/20578
(35.24%)	8098/22977
(35.64%)	27503/77165
(35.95%)	26448/73565
(36.05%)	11483/31857
(36.06%)	15273/42359
(36.28%)	12408/34205
(36.33%)	11574/31860
(36.37%)	9628/26471
(36.61%)	883/2412
(36.62%)	11788/32193
(36.76%)	8958/24372
(36.94%)	18006/48747
(37.01%)	6519/17613
(37.53%)	14786/39402
(37.64%)	14889/39553
(37.76%)	9692/25669
(38.00%)	8985/23642
(38.98%)	12464/31973
(40.19%)	11967/29777
(40.32%)	15679/38883
(40.32%)	9314/23103
(40.53%)	13075/32260
(40.56%)	7444/18355
(40.90%)	11172/27315
(40.91%)	16091/39330
(41.15%)	7654/18600
(41.25%)	7362/17846
(41.40%)	6840/16523
(41.60%)	7005/16838
(41.67%)	8820/21168
(41.98%)	10978/26151
(42.12%)	9648/22905
(42.60%)	7819/18353
(42.82%)	13412/31324
(43.03%)	17539/40759
(43.56%)	12020/27597
(43.97%)	13500/30704
(44.18%)	15718/35580
(44.27%)	1042/2354
(44.31%)	19255/43453
(44.78%)	11394/25446
(45.43%)	13161/28972
(45.62%)	14590/31980
(45.96%)	928/2019
(46.40%)	11130/23987
(46.47%)	7961/17130
(46.68%)	9383/20099
(46.80%)	6725/14371
(47.40%)	27211/57410
(47.83%)	10345/21628
(47.86%)	1053/2200
(47.96%)	15006/31287
(48.00%)	10170/21187
(48.21%)	8939/18543
(48.51%)	23072/47564
(48.92%)	7888/16124
(49.01%)	16235/33126
(49.04%)	7488/15268
(49.61%)	8206/16540
(51.88%)	829/1598
(52.37%)	10034/19159
(53.56%)	13601/25395
(53.58%)	13380/24970
(54.77%)	22570/41212
(56.55%)	10402/18393
(56.58%)	11657/20603
(56.86%)	12059/21207
(59.49%)	12010/20188
(60.19%)	22016/36575
(62.39%)	7277/11664
(64.49%)	6710/10405
